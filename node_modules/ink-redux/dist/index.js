'use strict';
const React = require('react')
const PropTypes = require('prop-types')
const { bindActionCreators } = require('redux');
const { h, Component } = require('ink');

class Provider extends React.Component {
	render() {
		return this.props.children;
	}

	getChildContext() {
		return {
			store: this.props.store
		};
	}
}

Provider.childContextTypes = {
  store: PropTypes.object
};

const defaultMergeProps = (stateProps, dispatchProps, ownProps) => {
	return Object.assign({}, ownProps, stateProps, dispatchProps);
};

const connect = (mapStateToProps, mapDispatchToProps, mergeProps = defaultMergeProps) => {
	return WrappedComponent => {
		class ConnectedComponent extends React.Component {
			render(ownProps, state) {
				const { dispatch, getState } = this.context.store;
				let stateProps;
				let dispatchProps;

				if (typeof mapStateToProps === 'function') {
					stateProps = mapStateToProps(getState(), ownProps);
				}

				if (mapDispatchToProps) {
					if (typeof mapDispatchToProps === 'function') {
						dispatchProps = mapDispatchToProps(dispatch, ownProps);
					}

					if (typeof mapDispatchToProps === 'object') {
						dispatchProps = bindActionCreators(mapDispatchToProps, dispatch);
					}
				} else {
					dispatchProps = { dispatch };
				}

				return React.createElement(WrappedComponent, mergeProps(stateProps, dispatchProps, ownProps));
			}

			componentDidMount() {
				if (typeof mapStateToProps === 'function') {
					this.unsubscribe = this.context.store.subscribe(() => {
						this.forceUpdate();
					});
				}
			}

			componentWillUnmount() {
				if (typeof this.unsubscribe === 'function') {
					this.unsubscribe();
				}
			}
    }

    ConnectedComponent.contextTypes = {
      store: PropTypes.object
    };

		return ConnectedComponent;
  };
  
  
};

exports.Provider = Provider;
exports.connect = connect;